## 一、基础架构

#### 常见软件架构

- MVC

- MQ为核心的事件驱动

- 管道-过滤器(责任链)

- 微核-插件

#### 常见的存储引擎

存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。如果不指定引擎类型，默认使用的就是 InnoDB。

支持事务、外键。支持崩溃修复和并发控制

- MyISAM

MySQL 5.5.5之前的默认存储引擎，不支持事务，使用B+树结构，空间利用率高

- Memory

所有数据都在内存中，安全性差，适合建内存临时表

- Archive

数据压缩、空间利用率高，插入速度快，不支持索引，查询性能差。

<img src="./img/arch.webp" alt="Mysql架构" />

#### 客户端与MySQL的连接方式

1. TCP/IP连接  header+payload
2. 命名管道 同一台机器内部通信 --enable-named-pipe
3. 共享内存 同一台机器内部通信 
4. UNIX域套接字 同一台机器内部建立socket

#### SQL语句的执行流程

- 连接命令

连接命令一般是：

```mysql
mysql -h$ip -P$port -u$user -p
```

如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。连接建立以后，权限就确定下来。如果发生变化，需要下次重新连接时生效。连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，客户端如果太长时间没动作，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。

MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。一个连接经过大量的sql操作后，会占用大量的临时内存，只有断开连接后，内存才会回收。如果长连接累积下来，可能导致内存占用太大，导致OOM。

解决方案：

1. 定期断开长连接。或程序里判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。
2. MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection (API函数)来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态：

- - 回滚活跃的事务并重新设置自动提交模式
  - 释放所有表锁
  - 关闭或删除所有的临时表
  - 重新初始化会话的系统变量值 丢失用户定义的设置变量
  - 释放prepare语句 关闭handler变量 

- 查询缓存

  之前执行过的**查询**语句会以K-V的形式缓存在内存中（会在优化器之前做precheck对用户是否有对该表的权限做验证），K是SQL语句，V是语句执行结果。

  不推荐使用：数据表修改后，会删除该表的所有的相关缓存，失效非常频繁。MySQL8.0后已将查询缓存删除。

- 分析器

  1. 词法分析，识别传进来的字符串、识别SQL语句中的关键字。
  2. 句法分析，判断SQL语句是否符合语法。
  3. 如果有错误，会报“You have an error in your SQL syntax”的错误。

- 优化器

  1. 主要工作是决定使用哪个索引，原则是尽可能扫描少的数据库行记录。
  2. 在一个语句有多表关联（join）的时候，决定各个表的连接顺序

- 执行器

  1. 校验用户对目标数据有无权限，一般是对存储过程、触发器、函数之类的验证，因为在这些模块中是可能会调用到其他的表的，MySQL需要判断当前用户是否有对这些调用到的表的权限。
  2. 以行为粒度调用存储引擎，执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。执行器每次调用引擎的次数为rows_examined的值，一般小于真正扫描的行数。

## 二、索引

### 索引组织表（Index Organized Table）

索引组织表是由索引组织起来的表，在InnoDB中，表都是根据主键顺序组织存放的，数据表均为索引组织表。使用的数据结构为B+树

### 索引（Index）

索引是数据库中对某一列或多个列进行预排序的数据结构。InnoDB使用B+树作为索引的数据结构，索引分为聚簇索引（主索引）和辅助索引。

- 聚簇索引（索引和数据在一起）
  - 根据表的主键构造一个B+树
  - 叶节点直接存放行数据

- 辅助索引
  - 每张表可以有多个索引，每一个辅助索引都对应一个B+树
  - 叶子节点并不包含行数据，记录的是行数据的主键，用来指示数据位置。也就是在叶子节点中，Key是辅助索引的字段，Value是对应主键（假设是3）的值，再从主索引中找对应主键（3）的记录。



### 主键（Primary Key）

如果表中有一个非空唯一索引（Unique NOT NULL），即为主键。如果有多个非空唯一索引，选择第一个定义的索引。如果都没有，InnoDB会自动创建一个6字节的指针作为主键。

### 数据结构

##### AVL Tree？

解决了二叉搜索树可能退化为线性查找的缺点。

但每个节点只包含一条数据，而磁盘有最小读写单位，假设为4K，如果不足4K，该数据块的剩余部分将会被浪费，或者选择将该数据存储到其他块中，空间的浪费将是巨大的。

##### B Tree？

线性数据结构和树的结合，通过多数据节点大大降低了树的高度，因为在磁盘中查找下一条记录的开销是巨大的。且不需要旋转就可以保证树的平衡。

但范围查找的性能很低

##### B+ Tree

高度一般为2-4层，所有的数据都在叶节点。在同层B+树节点之间为**双向**链表，在B+树节点之内，数据条目之间为**单向**链表。采用索引指示数据。叶结点之间用指针形成线性链表。解决了范围查找性能低的问题。

### 数据表的逻辑存储结构

- 表空间 tablespace

  数据表在硬盘上的存储空间，默认所有表数据都存在共享表空间，也可以放在独占表空间
  
- 段 segment 段由InnoDB管理，一个段中有多个区。 

  - Leaf node segment 只存放B+树的叶子节点
  - Non-Leaf node segment 只存放B+树的非叶子节点
  - Rollback segment
  
- 区 extent

由连续页组成的空间，在InnoDB中，默认一个区有64个page，每个page 16KB，总大小为1MB

- 页 page

页是InnoDB中磁盘读写的最小逻辑单位，默认16KB。一个数据页就是一个B+树的节点。在磁盘上看每个页都是连续存储的，但每个page有它下层节点的指针，因此在区中页的物理结构和逻辑结构是不同的。

- 行 row

数据真正存储的地方，分为行指针、事务id、数据行





